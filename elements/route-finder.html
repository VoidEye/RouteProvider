<!DOCTYPE html>
<html>
<head>
	<link href="../bower_components/polymer/polymer.html" rel="import">
	<link href="../bower_components/paper-drawer-panel/paper-drawer-panel.html" rel="import">
	<link href="../bower_components/paper-header-panel/paper-header-panel.html" rel="import">
	<link href="../bower_components/paper-toolbar/paper-toolbar.html" rel="import">
	<link href="../bower_components/paper-icon-button/paper-icon-button.html" rel="import">
	<link href="../bower_components/paper-material/paper-material.html" rel="import">
	<link href="../bower_components/paper-menu/paper-menu.html" rel="import">	
	<link href="../bower_components/paper-item/paper-item.html" rel="import">
	<link href="../bower_components/paper-input/paper-input.html" rel="import">
	<link href="../bower_components/paper-fab/paper-fab.html" rel="import">
	<link href="../bower_components/paper-button/paper-button.html" rel="import">
	<link href="../bower_components/iron-icons/iron-icons.html" rel="import">
	<link href="../bower_components/leaflet-map/leaflet-map.html" rel="import">
	<link href="../bower_components/paper-radio-group/paper-radio-group.html" rel="import">
	<link href="../bower_components/paper-radio-button/paper-radio-button.html" rel="import">
	<link href="../bower_components/paper-card/paper-card.html" rel="import">
	<link href="../bower_components/Sortable/Sortable.html" rel="import">
	
	<link href="journey-table.html" rel="import">

	<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
  	<script src="//code.jquery.com/jquery-1.10.2.js"></script>
  	<script src="//code.jquery.com/ui/1.11.4/jquery-ui.js"></script>

	<link rel="stylesheet" href="../leaflet/leaflet.css" />
	<script src="../leaflet/leaflet.js"></script>
	<script src="../leaflet/leaflet-src.js"></script>

	<link rel="stylesheet" href="../ControlGeoCoder/Control.Geocoder.css" />
	<script src="../ControlGeoCoder/Control.Geocoder.js"></script>

	<link rel="stylesheet" href="../leaflet-search/leaflet-search.css" />
	<script src="../leaflet-search/leaflet-search.js"></script>
</head>

<dom-module id="route-finder">
	<style>
		#DirectionsEntry {
			margin-top: 15px;
			padding-top: 50px;
			max-height: 200px;
		}
		#JourneyOptions {
			width: 120px;
			margin-top: 30px;
		}
		#jTable{
			margin-left: 20px;
			margin-top: 40px;
		}
		#hourPicker, #minutePicker{
			width: 25px;
		}
		#datePicker{
			width: 75px;
			margin-top: 15px;
		}
		#getToday{
			background-color: 5059FF;
			font-size: 12px;
			margin-top: 5px;
		}
		#swap{
			background-color: 5059FF;
			max-width: 10px;
			font-size: 10px;
			margin-top: 5px;
		}
		.main-panel {
			background-color: #eee;
			height: 100vh;
			overflow-y: hidden;
		}
		.mainButton{
			margin-top: 40px;
			width: 40;
			height: 30px;
		}
		#internal{
			width:180px;
		}
		#stepAdder{
			background-color: green;
			height: 25px;
			margin-top: 15px;
			min-width: 35px;
			padding: 0px;
		}
		#journeyAdder{
			background-color: grey;
			height: 25px;
			margin-top: 15px;
			min-width: 35px;
			padding: 0px;
		}
		paper-material {
			background-color: #fff;
			max-width: 640px;
			width: 95%;
			margin: 25px auto;
			position: relative;
		}
		paper-toolbar {
			color: black;
			background: #C7EDFF;
			float: left;
			width: 100%;
			height: 150px;
		}
		paper-input.route-finder {
			height: 40;
			margin-bottom: 5px;
			max-width: 140px;
		}
		paper-input{
			max-width: 140px;
		}
		paper-header-panel{
			height: 151px;
		}
		paper-drawer-panel{
			height: 100%;
			position: relative;
			--paper-drawer-panel-main-container: {
				background-color: C7EDFF;
			};
			--paper-drawer-panel-left-drawer-container: {
				background-color: #91DBFF;
			};
		}
	</style>
  
	<template>
		<paper-header-panel>
			<paper-toolbar elevation="2">
				<div id="DirectionsEntry" class="top">

				<template id="journeyTableT" is="dom-repeat" items="{{jTables}}">	
					<journey-table id="{{item.htmlID}}"></journey-table>
					<paper-fab id="{{item.mainButtonID}}" icon="icons:reply" on-click="forwardRequest" journey-number$="{{item.num}}" class="mainButton"></paper-fab>
				</template>
			</div>
				<div id="addTableDiv">
					<paper-button raised id="journeyAdder" on-click="addTable"> 
    					<iron-icon id"addStepIcon" icon="add"></iron-icon></paper-button>
				</div>    					
			</paper-toolbar>
		</paper-header-panel>
		<paper-drawer-panel>
			<div drawer>
				<paper-card heading="Card Title">
 	 				<div class="card-content">Some content</div>
  					<div class="card-actions">
    					<paper-button>Some action</paper-button>
  					</div>
				</paper-card>
				<paper-card heading="Card Title">
  					<div class="card-content">Some content</div>
  					<div class="card-actions">
    					<paper-button>Some action</paper-button>
  					</div>
				</paper-card>
			</div>
			<div main>
				<leaflet-map id="warsawMap" latitude="52.2297" longitude="21.0122" zoom="12">
				</leaflet-map>
			</div>
		</paper-drawer-panel> 
	</template>

<script>
  Polymer({
    is: "route-finder",

    properties: {
    	startPointSet: {
    		type: Boolean,
    		value: true
    	},
    	jTables: {
    		type: Array,
    		value:[{htmlID: "jTid0", num:  0, mainButtonID: "mB0"}]
    	},
    	/*
    	 * Potrzebuję aby każdy button odpowiadał za swoją tabelę, czyli addStep musiałby ściągać 
    	 * idTabeli i tylko dla tej tabeli zwiększać wartość, albo z każdą nową wartością wpisywać
    	 * nowy property, albo zrobić property 2DArray i  wiersze to oddzielne tabele, a kolumny to
    	 * kolejne przystanki.
    	 */
    },

    addTable: function(){
    	//Nadawaj oddzielnie properties dla każdego nowego journey-table
    	var lastItem = this.jTables[this.jTables.length-1];
    	lastItem = 1 + lastItem.num;
    	var newID = "jTid" + lastItem;
    	var newBID = "mB" + lastItem;
    	this.push('jTables', {htmlID: newID ,num: lastItem, mainButtonID: newBID});
    },
    forwardRequest: function(e){
    	//Dać możliwość wprowadzania koordynatorów zamiast nazw, tylok jeżeli będzie poza jakimśzakresem, to wyrzucać wyjatek, albo mieć to w dupie i czekać aż OTP nie znajdzie połączenia.
    	//var geocoder = new L.Control.Geocoder.Nominatim();
    	if(e.target.id === "icon"){
    		var jNumber = e.target.parentNode.getAttribute('journey-number');
    		//console.log(e.target.parentNode.id);
    	}
    	else
    		var jNumber = e.target.getAttribute('journey-number');

    	var chTabID = "#jTid" + jNumber;
    	// Brać element "journey-table", a potem brać childa o danym ID? 
    	//Chyba jednak rozwiązanie nr. jeden. A może jest jeszcze jakieś?
    	// Jeżeli mogę dostać się do propertisów journey-table z poziomu route-findera, to może mogę łatwo stowrzyć array z ID elementów i wtedy chyba byłoby szybicej?
    	//Lepiej(?): Po kliknięciu na button zwraca cały journey-table i z tego czytamy properties/input-id, tylko przycisk musiały obsługiwać funckje z tego elementu.
    	//this.$$(chTabID);
    	//console.log(document.getElementById(chTabID));
    	var choosenTab = document.getElementById(chTabID);
    	//console.log(choosenTab.inputStop0);
    	var inputS = this.$$(chTabID).querySelector('#inputStop0');

    	console.log(inputS.value);
    	//var startAdress = this.$.startElemName.value;
    	var stopAdress = this.$.inputStop.value;

    	/*
    	switch()
    	var startAdress = this.$.inputStart.value;
    	var stopAdress = this.$.inputStop.value;

	 	if (/[a-z]/i.test(startAdress) === true){
    		geocoder.geocode(startAdress, getCoordsStart);
    	}
    	else{
    		var cordsArr = startAdress.split(",");
    		var toPass = [];
    			toPass[0] = {
    			name: "",
    			center: L.latLng(cordsArr[0], cordsArr[1])
    		}
    		getCoordsStart(toPass);
    	}	
    	if (/[a-z]/i.test(stopAdress) === true){
	 		geocoder.geocode(stopAdress, getCoordsStop);
	 	}
	 	else{
	 		var cordsArr = stopAdress.split(",");
    		var toPass = [];
    		toPass[0] = {
    			name: "",
    			center: L.latLng(cordsArr[0], cordsArr[1])
    		}
    		getCoordsStop(toPass);
	 	}*/

	 	function getCoordsStart(results){
       		var latLngStart = new L.LatLng(results[0].center.lat, results[0].center.lng);
       		var startName = results[0].name;
       		var startPointCoords = {coords:latLngStart, stopName:name};
       		accumulateCoords(startPointCoords, 0);
		}
		function getCoordsStop(results){   	
			var latLngStop = new L.LatLng(results[0].center.lat, results[0].center.lng);
       		var stopName = results[0].name;
       		var stopPointCoords = {coords:latLngStop, stopName:name};
       		accumulateCoords(stopPointCoords, 1);
       	}

       	function accumulateCoords(coordsArray, iWhichOne){
       		accumulateCoords.start_stop = accumulateCoords.start_stop || []
			accumulateCoords.accumulationStatus = ++accumulateCoords.accumulationStatus || 1;
			if(iWhichOne === 0){
				accumulateCoords.start_stop[0] = coordsArray; 
				setMarker("start", coordsArray.coords);
			}
			if(iWhichOne === 1){
				accumulateCoords.start_stop[1] = coordsArray; 
				setMarker("stop", coordsArray.coords);
			}

	 		if(accumulateCoords.accumulationStatus === 2){
	 			accumulateCoords.accumulationStatus = 0;
	 			sendToOTP(accumulateCoords.start_stop);	
	 		}
       	}
    },

	/*{Wyniki z searcha trzeba by przepuszczać przez własną funkcje i wyświetlać w podpwoeidziach do 
		inputu, przy kliknięciu uruchamiać geocoder i rysować marker, a dopiero przy kliknięciu guzika 
		szukać trasy, + przesuwanie i ustawianie markera za pomocą myszy.
		Czyli:
		1. Implementacja searcha i funkcji do któej zbiera wyniki
		2. wyświetlanie wyników w podpowiedziach przy 'inpucie' i wyswiettla w panelu

		geosearch limitowany/priorytyzowany dla konkretnej lokacji to jest must./
		//stwórz zmienną w której będziesz dodawł przekazane do funkcji parametr np. 1+2
		accumulateCoords.start_stop = accumulateCoords.start_stop || []
		accumulateCoords.accumulationStatus = ++accumulateCoords.accumulationStatus || 1;
	},*/

	printResults: function(jResp){
		//var d = new Date(0);
		//d.setUTCSeconds(journeyDate);
		var startStop = jResp.plan.from.name;
		var endStop = jResp.plan.to.name;

		for(i = 0; i < jResp.plan.itineraries.length; ++i){
			//pack all variables in some div/PolymerObject?
			//So I could pre-define polymer-element,
			//Call on it upon button press
			//Fill it with variables upn reciving an answer.
			//To do this, I need to know what kind, and how many variables there will be.
			/*
			* Tworzyć za pomocą dom-ifa karty/nagłówki
			* Karto-nagłówki winny być osobnymi polymero-elementami
			* Pakowanie danych do tych elementów: Przesłać obiekt z danymi z tej funkcji
			* Np. funkcja 'setParametres' która przyjmuje obiekt i później wszystko ładnie uzupełnia.
			* Okej, to na dom-if potrzebna jest zmienna, Czy da się ją ustawiać spoza polymerowego scopa?
			* Czy da się wywołać funkcje(tą) spoza polymero-scopa do elementu w dom-if? 
			*/
			var travelDuration = jResp.plan.itineraries[i].duration;
			var travelTimeEnd = jResp.plan.itineraries[i].endTime;
			var travelTImeBegin = jResp.plan.itineraries[i].startTime;
			var transfers = jResp.plan.itineraries[i].transfers;
			var transitTime = jResp.plan.itineraries[i].transitTime;
			var waitingTime = jResp.plan.itineraries[i].waitingTime;
			var approxWalkTime = jResp.plan.itineraries[i].walkTime;
			var walkDistance = jResp.plan.itineraries[i].walkDistance;
			
			for(j = 0; j < jResp.plan.itineraries[i].legs.length; ++j){
				var phaseDistance = jResp.plan.itineraries[i].legs[j].distance;
				var phaseTime = jResp.plan.itineraries[i].legs[j].duraton;
				var phaseEndTime = jResp.plan.itineraries[i].legs[j].endTime;
				var phaseStartTime = jResp.plan.itineraries[i].legs[j].startTime;
				var route = jResp.plan.itineraries[i].legs[j].route;
				var routeLongName = jResp.plan.itineraries[i].legs[j].routeLongName;
				var mode = jResp.plan.itineraries[i].legs[j].mode;
				var from = jResp.plan.itineraries[i].legs[j].from.name;
				var fArrival = jResp.plan.itineraries[i].legs[j].from.arrival;
				var fDeparture = jResp.plan.itineraries[i].legs[j].from.departure;
				var fStopLat = jResp.plan.itineraries[i].legs[j].from.lat;
				var fStopLng = jResp.plan.itineraries[i].legs[j].from.lon;
				var to = jResp.plan.itineraries[i].legs[j].to.name;
				var toArrival = jResp.plan.itineraries[i].legs[j].to.arrival;
				var toDeparture = jResp.plan.itineraries[i].legs[j].to.departure;
				var toStopLat = jResp.plan.itineraries[i].legs[j].to.lat;
				var toStopLng = jResp.plan.itineraries[i].legs[j].to.lon;
				console.log(from + " i= " + i + " j= " + j); 
			}
		}	
	},

    swapStartStop: function(){
    	var tmp = this.$.inputStart.value;
    	this.$.inputStart.value = this.$.inputStop.value;
		this.$.inputStop.value = tmp;
    },

	ready: function(e){
		window.onresize = function(event) {
		};
		window.onresize();
	},
  });



	/*TODO: Autocomplete/search, Odbieranie i ładne wypisywanie odpowiedzi, oraz rysowanie linii między punktami, geolocation
			SetMarker powinien być na enter, po wybraniu lokalizacji.*/
	var popup;



	window.addEventListener('WebComponentsReady', function(e){
		var map = document.getElementById("warsawMap").map;
		//Podpisz te koordy, jako boundaries np.
    	southWest = L.latLng(51.991645772197344, 20.558853149414062),
    	northEast = L.latLng(52.396134469429214, 21.430892944335938),
   		bounds = L.latLngBounds(southWest, northEast);
    	map.setMaxBounds(bounds);

    	

    	map.on('contextmenu', function(e){
    		var popUpContent = "<div onClick=\"setMarkerFromClick\(\'start\'\)\">Przystanek startowy</div><div onClick=\"setMarkerFromClick\(\'stop\'\)\">Przystanek docelowy</div>";
    		popup = L.popup()
    		.setLatLng(e.latlng)
    		.setContent(popUpContent);
    		popup.openOn(map);
    	});
	}),
	
	window.setMarkerFromClick = function(id){
		var latlng = popup.getLatLng();
		if(id === 'start'){
			document.getElementById('inputStart').value = latlng.lat + "," + latlng.lng;
		}
		else if(id === 'stop'){
			document.getElementById('inputStop').value = latlng.lat + "," + latlng.lng;
		}
		$(".leaflet-popup-close-button")[0].click();
		setMarker(id, latlng);
	}
	L.Icon.Default.imagePath = "../images";



	function setMarker(id, latLng){
		setMarker.markers = setMarker.markers || {};
		if(setMarker.markers[id] != null)
			setMarker.markers[id].setLatLng(latLng);
		else{
			var marker;
			if(id === 'start'){
				var startIcon = new L.Icon({iconUrl: '../images/starterMarker.png', iconSize: [38, 35]});
				marker = new L.marker(latLng, {id:id, icon:startIcon, draggable:'true'});
				setMarker.markers[id] = marker;
				marker.on('dragend', function(){
					var markerCoords = setMarker.markers['start'].getLatLng();
					document.getElementById('inputStart').value = markerCoords.lat + "," + markerCoords.lng;
				});
			}
			else if(id === 'stop'){
				marker = new L.marker(latLng, {id:id, draggable:'true'});
				setMarker.markers[id] = marker;
				marker.on('dragend', function(){
					var markerCoords = setMarker.markers['stop'].getLatLng();
					document.getElementById('inputStop').value = markerCoords.lat + "," + markerCoords.lng;
				});
			}
			var parent = document.getElementById('warsawMap').map;
			parent.addLayer(marker);
		}
	}

	function sendToOTP(start_stopCoords){	
		var arriveBy = (document.getElementById('selection').selected === "Departure") ? 'false' : 'true';
		var maxWalkDistance = document.getElementById('maxWalk').value;
		var date = document.getElementById('datePicker').value;
		var hours = document.getElementById('hourPicker').value; 
		var suffix = (hours >= 12)? 'pm' : 'am';
		
		date = date.replace(/\//g,"-");
		hours = ((parseInt(hours)+11)%12)+1;
		
		var time = hours + ":" + document.getElementById('minutePicker').value + suffix;

		var requestString = "http://violet.temote.pl:8080/otp/routers/default/plan?fromPlace=" + start_stopCoords[0].coords.lat + "," + start_stopCoords[0].coords.lng + "&toPlace=" + start_stopCoords[1].coords.lat + "," + start_stopCoords[1].coords.lng + "&time=" + time + "&date=" + date + "&mode=TRANSIT,WALK&maxWalkDistance=" + maxWalkDistance + "&arriveBy=" + arriveBy + "&wheelchair=false&locale=en";

		var response;
    	var reqHandler = new XMLHttpRequest();

 		reqHandler.addEventListener("load", processRequest);
    	reqHandler.open('GET',requestString , true);
    	reqHandler.send();

    	function processRequest(e){
    		if(reqHandler.status == 200){
  				response = JSON.parse(reqHandler.responseText); 
  				//printResults(response);
  				console.log(response);
  			}
		}
	}
	

/*
DEBUG STRING:

http://violet.temote.pl:8080/otp/routers/default/plan?fromPlace=52.1836118,20.9790984&toPlace=52.2458726,20.9402570333431&time=2:44pm&date=02-04-2016&mode=TRANSIT,WALK&maxWalkDistance=804.672&arriveBy=false&wheelchair=false&locale=en
*/	
</script>
</dom-module>
